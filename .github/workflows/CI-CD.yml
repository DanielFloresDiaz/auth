name: CI-CD

on:
  push:
    branches:
      - main
      - master
    tags:
      - '*'
    paths-ignore:
      - '**/*.md'
      - '**/*.toml'
      - '**/*.lock'
      - '**/*.json'
      - '**/*.txt'
      - '**/*.env'
  pull_request:
    paths-ignore:
      - '**/*.md'
      - '**/*.toml'
      - '**/*.lock'
      - '**/*.json'
      - '**/*.txt'
      - '**/*.env'
  workflow_dispatch:

permissions:
  contents: read
  packages: write  # Add permission to push to GHCR

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
      - name: Install Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
      - name: Check gofmt
        run: |
          set -x

          if [ ! -z $(gofmt -l .) ]
          then
            echo 'Make sure to run "gofmt -s -w ." before commit!' && exit 1
          fi
      - name: Check go vet
        run: |
          set -x
          go vet ./...
      - name: Run static check
        run: |
          set -x
          make static
      - name: Check gosec
        run: |
          set -x
          make sec

  test:
    if: ${{ !contains(github.event.head_commit.message, '[skip test]') && (github.event.pull_request.head.repo.full_name == github.repository || github.event_name == 'push') }}
    needs: [lint]
    strategy:
      matrix:
        go-version: [1.25.5]
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: root
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
      - name: Install Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ matrix.go-version }}
      - name: Init Database
        run: psql -f hack/init_postgres.sql postgresql://postgres:root@localhost:5432/postgres
      - name: Run migrations
        run: make migrate_dev
      - name: Run liquibase migrations - public
        uses: liquibase-github-actions/update@v4.30.0
        with:
          changelogFile: 'liquibase_migrations/changelog-public.sql'
          url: 'jdbc:postgresql://postgres:5432/postgres'
          username: 'postgres'
          password: 'root'
          rollbackOnError: 'true'
      - name: Run liquibase migrations - auth
        uses: liquibase-github-actions/update@v4.30.0
        with:
          changelogFile: 'liquibase_migrations/changelog-auth.sql'
          url: 'jdbc:postgresql://postgres:5432/postgres'
          username: 'postgres'
          password: 'root'
          rollbackOnError: 'true'
      - name: Run liquibase migrations - rls-auth
        uses: liquibase-github-actions/update@v4.30.0
        with:
          changelogFile: 'liquibase_migrations/changelog-rls-auth.sql'
          url: 'jdbc:postgresql://postgres:5432/postgres'
          username: 'postgres'
          password: 'root'
          rollbackOnError: 'true'
      - name: Run liquibase migrations - index-auth
        uses: liquibase-github-actions/update@v4.30.0
        with:
          changelogFile: 'liquibase_migrations/changelog-index-auth.sql'
          url: 'jdbc:postgresql://postgres:5432/postgres'
          username: 'postgres'
          password: 'root'
          rollbackOnError: 'true'
      - name: Run liquibase migrations - grants-auth
        uses: liquibase-github-actions/update@v4.30.0
        with:
          changelogFile: 'liquibase_migrations/changelog-grants-auth.sql'
          url: 'jdbc:postgresql://postgres:5432/postgres'
          username: 'postgres'
          password: 'root'
          rollbackOnError: 'true'
      - name: Run liquibase migrations - procedures-auth
        uses: liquibase-github-actions/update@v4.30.0
        with:
          changelogFile: 'liquibase_migrations/changelog-procedures-auth.xml'
          url: 'jdbc:postgresql://postgres:5432/postgres'
          username: 'postgres'
          password: 'root'
          rollbackOnError: 'true'
      - name: Run tests
        run: make test 2>&1 | tee test-output.log
      - name: Store coverage file
        uses: actions/upload-artifact@v4
        with:
          name: coverage-file
          path: coverage.out
          retention-days: 1
      - name: Upload test logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-logs
          path: test-output.log

  coverage:
    needs: [test]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
      - name: Install Go
        uses: actions/setup-go@v6
        with:
          go-version: 1.25.5
      - name: Download coverage file
        uses: actions/download-artifact@v4
        with:
          name: coverage-file
      - name: Cleanup coverage
        run: |
          set -x

          # since Go 1.20 these source files need to be deleted from the
          # coverage profile as they contain legacy or untestable code (like
          # `main` package)

          sed -i '/^github.com\/supabase\/auth\/client/d' coverage.out
          sed -i '/^github.com\/supabase\/auth\/cmd/d' coverage.out
          sed -i '/^github.com\/supabase\/auth\/docs/d' coverage.out
          sed -i '/^github.com\/supabase\/auth\/main/d' coverage.out
      
      - name: Generate coverage reports
        run: |
          go tool cover -html=coverage.out -o coverage.html

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-reports
          path: |
            coverage.out
            coverage.html
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage.out
          fail_ci_if_error: true
          verbose: true
      
      - uses: shogo82148/actions-goveralls@v1
        with:
          path-to-profile: coverage.out

  # Add check-skip job for when tests are skipped
  check-skip:
    if: ${{ contains(github.event.head_commit.message, '[skip test]') }}
    needs: [lint]
    runs-on: ubuntu-latest
    steps:
      - name: Skip tests
        run: echo "Tests skipped but proceeding with workflow"

  # https://github.com/marketplace/actions/alls-green#why used for branch protection checks
  check:
    if: ${{ !contains(github.event.head_commit.message, '[skip test]') }}
    needs: [lint, test, coverage]
    runs-on: ubuntu-latest
    steps:
      - name: Decide whether the needed jobs succeeded or failed
        uses: re-actors/alls-green@release/v1
        with:
          jobs: ${{ toJSON(needs) }}

  release:
    # Depend on both check and check-skip jobs
    needs: [check, check-skip]
    # Run if either check or check-skip succeeded, and we're on a tag
    if: |
      always() &&
      ((needs.check.result == 'success') || (needs.check-skip.result == 'success')) &&
      startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write  # Required for pushing to GHCR
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
      - name: Install Go
        uses: actions/setup-go@v6
        with:
          go-version: 1.25.5
          
      # Extract version from GitHub tag
      - name: Extract version from Git tag
        id: tag_version
        run: |
          # Extract the version string from GITHUB_REF (refs/tags/v1.2.3 or refs/tags/1.2.3)
          TAG=${GITHUB_REF#refs/tags/}
          VERSION=$TAG
          # Check if this is a dev tag
          if [[ $TAG == dev* ]]; then
            IS_DEV_TAG="true"
            VERSION="dev"  # Fixed tag for all development builds
          else
            IS_DEV_TAG="false"
            VERSION=$TAG
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is_dev_tag=$IS_DEV_TAG" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION from tag $TAG (dev tag: $IS_DEV_TAG)"
          
      - name: Build binaries
        run: |
          CGO_ENABLED=0 go build -ldflags "-X github.com/supabase/auth/internal/utilities.Version=${GITHUB_REF#refs/tags/}" -o auth
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags "-X github.com/supabase/auth/internal/utilities.Version=${GITHUB_REF#refs/tags/}" -o auth-linux-amd64
          CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags "-X github.com/supabase/auth/internal/utilities.Version=${GITHUB_REF#refs/tags/}" -o auth-linux-arm64
      
      # Docker build and push steps
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            # For dev tags, use a single fixed "dev" tag
            ${{ steps.tag_version.outputs.is_dev_tag == 'true' && format('type=raw,value={0}', steps.tag_version.outputs.version) || '' }}
            # For production releases, use semantic versioning tags
            ${{ steps.tag_version.outputs.is_dev_tag != 'true' && 'type=semver,pattern={{version}}' || '' }}
            ${{ steps.tag_version.outputs.is_dev_tag != 'true' && 'type=semver,pattern={{major}}.{{minor}}' || '' }}
            ${{ steps.tag_version.outputs.is_dev_tag != 'true' && 'type=semver,pattern={{major}}' || '' }}
            ${{ steps.tag_version.outputs.is_dev_tag != 'true' && 'type=raw,value=latest' || '' }}
            # Always include the commit SHA
            type=sha,format=short

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          file: ./dockerfiles/Dockerfile
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            RELEASE_VERSION=${{ steps.tag_version.outputs.version }}
      
      # Skip release creation for dev tags
      - name: Create Release
        if: steps.tag_version.outputs.is_dev_tag != 'true'
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            auth
            auth-linux-amd64
            auth-linux-arm64
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false
          overwrite_files: true

  deploy:
    needs: [release]
    if: |
      always() && (needs.release.result == 'success')
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      id-token: write # Needed for GCP authentication
    
    env:
      GCP_PROJECT_NUMBER: ${{ secrets.GCP_PROJECT_NUMBER }}
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
      
      # Authentication with Google Cloud
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
      
      - name: Bind secrets
        run: bash .gcloud/bind-secrets.sh
      
      - name: Install gke-gcloud-auth-plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin
          echo 'export USE_GKE_GCLOUD_AUTH_PLUGIN=True' >> $GITHUB_ENV
      
      - name: Determine deployment environment
        id: deployment_env
        run: |
          # Extract tag directly from GITHUB_REF
          TAG=${GITHUB_REF#refs/tags/}
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          
          # Remove 'v' prefix if present for version comparison
          VERSION=${TAG#v}
          
          echo "deploy_dev=true" >> $GITHUB_OUTPUT
          
          if [[ $TAG == dev* ]] || [[ $VERSION =~ ^0\. ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "deploy_prod=false" >> $GITHUB_OUTPUT
            echo "Deploying to development environment with tag: $TAG"
          else
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "deploy_prod=true" >> $GITHUB_OUTPUT
            echo "Deploying to production environment with tag: $TAG"
          fi
      
      - name: Configure kubectl
        run: |
          gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} --region ${{ secrets.GKE_CLUSTER_REGION }} --project ${{ secrets.GCP_PROJECT_ID }}
      
      - name: Ensure base Kubernetes resources exist
        run: |
          kubectl apply -f k8s/serviceaccount.yaml
          kubectl apply -f k8s/app-secrets.yaml
          kubectl apply -f k8s/frontend-config.yaml
          kubectl apply -f k8s/managed-cert.yaml
          kubectl apply -f k8s/auth-network-policy.yaml
      
      - name: Generate GHCR Secret
        run: python scripts/k8s/generate_ghcr_secret.py -u ${{ github.actor }} -t ${{ secrets.GHCR_PAT }} -n solomon --apply
      
      - name: Install Kustomize
        run: |
          mkdir -p /tmp/kustomize_install
          cd /tmp/kustomize_install
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/
      
      - name: Deploy to dev
        if: steps.deployment_env.outputs.deploy_dev == 'true'
        run: |
          ENV=dev
          TAG=${{ steps.deployment_env.outputs.tag }}
          
          # Apply environment specific services
          kubectl apply -f k8s/services/service-$ENV.yaml
          kubectl apply -f k8s/services/auth-internal-lb-$ENV.yaml

          # Remove "v" prefix if present for Docker image tag
          DOCKER_TAG=${TAG#v}
          
          # Create a kustomization overlay to set the image tag
          cd kustomize/overlays/$ENV
          
          # Force lowercase for image name to match GHCR and existing manifests
          REPO_LOWER=$(echo "${{ github.repository }}" | tr 'A-Z' 'a-z')
          kustomize edit set image ghcr.io/$REPO_LOWER=ghcr.io/$REPO_LOWER:$DOCKER_TAG
          
          # Show the changes
          echo "Deploying image with tag: $DOCKER_TAG"
          cat kustomization.yaml
          
          # Apply Kustomize configuration
          kubectl apply -k .
          
          # Verify deployment
          # Set the correct deployment name based on environment
          DEPLOYMENT_NAME="dev-auth-deployment"
          INGRESS_NAME="dev-auth-ingress"
          
          echo "Verifying deployment: $DEPLOYMENT_NAME in namespace solomon"
          kubectl rollout status deployment/$DEPLOYMENT_NAME -n solomon
          
          # Verify the image version was updated
          DEPLOYED_IMAGE=$(kubectl get deployment/$DEPLOYMENT_NAME -n solomon -o jsonpath='{.spec.template.spec.containers[0].image}')
          echo "✅ Deployed image: $DEPLOYED_IMAGE"
          
          if [[ "$DEPLOYED_IMAGE" == *"$DOCKER_TAG"* ]]; then
            echo "✅ Correct image tag deployed!"
          else
            echo "❌ Incorrect image tag deployed!"
            exit 1
          fi
          
          # Verify ingress exists
          echo "Verifying ingress: $INGRESS_NAME in namespace solomon"
          if kubectl get ingress $INGRESS_NAME -n solomon > /dev/null 2>&1; then
            echo "✅ Ingress $INGRESS_NAME exists!"
          else
            echo "❌ Ingress $INGRESS_NAME does not exist!"
            exit 1
          fi
          
          echo "✅ Deployment to $ENV environment completed successfully!"
      
      - name: Deploy to prod
        if: steps.deployment_env.outputs.deploy_prod == 'true'
        run: |
          ENV=prod
          TAG=${{ steps.deployment_env.outputs.tag }}
          
          # Apply environment specific services
          kubectl apply -f k8s/services/service-$ENV.yaml
          kubectl apply -f k8s/services/auth-internal-lb-$ENV.yaml

          # Remove "v" prefix if present for Docker image tag
          DOCKER_TAG=${TAG#v}
          
          # Create a kustomization overlay to set the image tag
          cd kustomize/overlays/$ENV
          
          # Force lowercase for image name to match GHCR and existing manifests
          REPO_LOWER=$(echo "${{ github.repository }}" | tr 'A-Z' 'a-z')
          kustomize edit set image ghcr.io/$REPO_LOWER=ghcr.io/$REPO_LOWER:$DOCKER_TAG
          
          # Show the changes
          echo "Deploying image with tag: $DOCKER_TAG"
          cat kustomization.yaml
          
          # Apply Kustomize configuration
          kubectl apply -k .
          
          # Verify deployment
          # Set the correct deployment name based on environment
          DEPLOYMENT_NAME="auth-deployment"
          INGRESS_NAME="auth-ingress"
          
          echo "Verifying deployment: $DEPLOYMENT_NAME in namespace solomon"
          kubectl rollout status deployment/$DEPLOYMENT_NAME -n solomon
          
          # Verify the image version was updated
          DEPLOYED_IMAGE=$(kubectl get deployment/$DEPLOYMENT_NAME -n solomon -o jsonpath='{.spec.template.spec.containers[0].image}')
          echo "✅ Deployed image: $DEPLOYED_IMAGE"
          
          if [[ "$DEPLOYED_IMAGE" == *"$DOCKER_TAG"* ]]; then
            echo "✅ Correct image tag deployed!"
          else
            echo "❌ Incorrect image tag deployed!"
            exit 1
          fi
          
          # Verify ingress exists
          echo "Verifying ingress: $INGRESS_NAME in namespace solomon"
          if kubectl get ingress $INGRESS_NAME -n solomon > /dev/null 2>&1; then
            echo "✅ Ingress $INGRESS_NAME exists!"
          else
            echo "❌ Ingress $INGRESS_NAME does not exist!"
            exit 1
          fi
          
          echo "✅ Deployment to $ENV environment completed successfully!"